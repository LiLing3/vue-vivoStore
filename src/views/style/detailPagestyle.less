li.list > a {
    color: darkorange;
  }
  button.list-style {
    &:extend(li.list > a); // use the same list styles
  }


  #outer() {
    .inner {
      color: red;
    }
    .inner2{
        color: aqua;
    }
  }
  .c {
    #outer > .inner();
  }
  .b{
    #outer > .inner2();
  }
.mixin(@color) {
    color-1: @color;
  }
  .mixin(@color; @padding: 2) {
    color-2: @color;
    padding-2: @padding;
  }
  .mixin(@color; @padding:3px; @margin: 2) {
    color-3: @color;
    padding-3: @padding;
    margin: @margin @margin @margin @margin;
  }
  .some .selector div {
    .mixin(#008000);
  }
  .truth(@a) when (@a) { 
    color: aqua;
  }
.truth(@a) when (@a = true) { 
  color: #000;
}
.class {
  .truth(true); // Will not match any of the above definitions.
}



@my-ruleset: {
  .my-selector {
    @media tv {
      background-color: black;
    }
  }
};
@media (orientation:portrait) {
  @my-ruleset();
}



// detached ruleset with a mixin
@detached-ruleset: { 
  .mixin() {
      color: blue;
  }
};
// call detached ruleset
.caller {
  @detached-ruleset(); 
  .mixin();
}